:::tip 前言

在所有计算机系统中，比特 (bit）都是最小的数据单位，它只能存储0或者1这两种状态。而实际上我们在使用的最小的数据单位应该是字节也就是byte,一个字节由8个bit组成。

当稍微深入一点点，我们就会遇到一个问题。那就是为什么字节的最小值是-128，最大值是127。
:::

## 什么是字节？

字节，计算机存储和处理信息的基本单位。一个字节由 8 个相邻的 二进制数字(位)组成，其实为什么是8位不用纠结了，这是规定好的和1+1=2一样。

## 字节的最大值和最小值

在计算机系统中，位是没有符号区别的，非0即1。但是实际上我们的手机或者电脑上是存在负数的，这其中是怎么实现的呢？这也是计算机系统中的特殊规定，也就是最高位标识符号位，0表示正数1表示负数。

### 字节的最大值

根据定义一个字节是8位，一个字节的最大值当然是正数最大，因此最高位0时，真值位都是1才是最大的值，最大值为2^6+2^5+2^4+2^3+2^2+2^1+2^0=64+32+16+8+4+2+1=127，加上符号位0的正数所以1个字节的最大值是+127，也就是说1个字节的最大值是：01111111B=127。

但是按照这个逻辑推算过去最小值应该为11111111B=-127才对呀，但是所有的书上都说byte的最小值是-128，这又是为什么呢？

按照我们最基本的理解，1个字节的最高位是符号位，那-1+1数学上应该为0，那转成二进制计算为：00000001B+10000001B=10000010B=-2，这明显就和事实不相符了。如果计算机中以这种方式去计算那整个世界都混乱了。

::: warning 重点
要明确一点，在计算机中存储的数据，都是存的数补码，千万不要搞错
:::

### 物理上的妥协

为了CPU的物理结构上更简单（电路上用二极管三极管实现加法器已经很麻烦了，再去实现减法器是不现实的。计算机科学家早就设计好用加法来代替减法了）。因此在计算机存储数据的时候都是存的数据的补码，CPU在计算数据的时候，不是简单的相加。所有数据都要转换成它的补码进行计算。正数的源码反码补码都是其自身，但是负数却发生了改变。

例如：10000001B是-1的原码，反码为11111110，补码为1111111。最终计算时都用补码计算，也就是1+（-1）=00000001B+11111111B=（1）00000000也就是0，这就解决了二进制中-1+1不等于0的问题。

### 字节的最小值为什么会是-128？

正数部分的取值范围，最终的补码（正数源码反码补码是一样的）00000000B-01111111B也就是0-127。

负数部分的补码为10000001-11111111，转回到原码应该是11111111-10000001十进制为-127 -（-1）。

**补码里面还有一个没有用。它就是10000000B**

因此计算机科学直接强行规定，补码中的10000000B表示-128，毕竟没有-0呀。

## 计算机中的妥协

从字节的最大最小值，其实我们可以看出为了符合实际的物理学等原理，方方面面都充满着妥协。

我们在面对各种实际的业务系统中其实妥协也是大量存在的，知道原理但是也要切合实际，不要当一个死读书的人。
